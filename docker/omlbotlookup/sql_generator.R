# This function will generate a query, which returns the 10 closest points in the database.
# These can then be used to calculate an interpolation of some sorts.
generate_query = function(task_id, input_ids, xs) {
  # length(input_ids) == length(xs)
  
  # This function will generate distinct names for use in the SQL query for the first, second, .. parameter
  generate_identifier = function(n) {
    paste0("p", seq_len(n))
  }
  
  # This function will generate a function to compute the euclidian distance between all points
  generate_sumterm = function(n) {
    names = generate_identifier(1:n)
    inner_sum = paste0("POW(", names,".distance, 2)", collapse=" + ")
    return(paste0("SQRT(", inner_sum, ")"))
  }
  
  # This function will make sure we only compare values from the same run, e.g. dont use parameter1 from one run and use parameter2 from another
  generate_equalsterm = function(n) {
    # In case of single parameter, there is only one subquery, therefore we don't need this function to tie them together.
    if(n == 1) {
      return("1 = 1")
    }
    
    names = generate_identifier(1:n)
    r = "first.setup = second.setup"
    if(n > 2) {
      for (i in 2:(n-1)) {
        name1 = names[i]
        name2 = names[i+1]
        r = paste0(r, " AND ", name1, ".setup = ", name2, ".setup")
      }
    }
    return(r)
  }
  
  # This function will generate the subquery for one parameter.
  # If the parameter value is given as a string, it will match only if there is that exact value in the database.
  # If the parameter value is a numeric, it will sort the results by distance to x.
  # The inner query is to limit the "search space" to those already computed on the given task.
  generate_subquery = function(input_id, x) {
    # is_numeric(input_id)
    # is_numeric(x)
    if (!is.na(suppressWarnings(as.numeric(x)))) {
      # FIXME: Trafo: 
      # value.trafo = sprintf(param$trafo.inverse.sql, "value")
      # value.x = sprintf(param$trafo.inverse.sql, x)
      return(paste0("SELECT setup, value, ABS(value - ", x, ")
                    AS distance
                    FROM input_setting
                    WHERE input_id = ", input_id, "
                    AND setup IN (SELECT setup FROM run WHERE task_id = ", task_id, ")
                    ORDER BY distance ASC"))
    } else {
      return(paste0("SELECT setup, value, 0 AS distance
                    FROM input_setting
                    WHERE input_id = ", input_id, "
                    AND value = '", x, "'
                    AND setup IN (SELECT setup FROM run WHERE task_id = ", task_id, ")
                    ORDER BY distance ASC"))
    }
  }
  
  # This function will generate subqueries for every given parameter.
  # The result looks something like
  # (SELECT ...) AS first, (SELECT ...) AS second
  # with the SELECT clauses generated by the function above, generate_subquery.
  generate_subqueries = function(input_ids, xs) {
    n = length(input_ids)
    names = generate_identifier(1:n)
    
    s = c()
    for(i in 1:n) {
      s = c(s, (paste0("(", generate_subquery(input_ids[i], xs[i]),") AS ", names[i])))
    }
    return(paste0(s, collapse=",\n    "))
  }
  
  n = length(input_ids)
  sumterm = generate_sumterm(n)
  equalsterm = generate_equalsterm(n)
  
  # Here the query is assembled. It will first get the subqueries for each parameter.
  # Then, the outer query will order these by euclidean distance and return the 10 nearest rows.
  return(paste0("SELECT
    ", sumterm, " AS sum_distance,
    first.setup AS setup
    FROM ", generate_subqueries(input_ids, xs), "
    WHERE ", equalsterm, " ORDER BY sum_distance LIMIT 10"))
}
