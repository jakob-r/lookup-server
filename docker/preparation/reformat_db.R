library("RMySQL")
library("data.table")
library("ParamHelpers")

source("paramToJSONList.R")

# Declare database credentials
mysql_username = "root"
mysql_password = ""
mysql_dbname_from = "openml"
mysql_dbname_to = "openml_exporting"
mysql_host = "127.0.0.1"

# Open database connection
con <- dbConnect(MySQL(), user = mysql_username, password = mysql_password, dbname = mysql_dbname_to, host = mysql_host)
parameter_ranges = readRDS("../omlbotlookup/parameter_ranges.Rds")

#' Queries the database for a list of all run parameter configurations with the given algorithm ids, on the given task_id with every parameter in parameter_names.
#'
#' @param algo_id Algorithm id (eg. 'mlr.classif.ranger')
#' @param task_id A single task_id, on which the algorithm has been run.
#' @param parameter_names A vector or list of 
#'
#' @return A dataframe containing: A column "setup", with the setup_id. A column "<parameter_name>" for every parameter. And one row of data for every setup, that has been run with one of the given algorithms, containing the parameter_data of that run.
getTableFromDB = function(task_id, algo_id) {
  parameter_names = names(parameter_ranges[[algo_id]]$pars)
  
  db_entries = lapply(parameter_names, function(parameter_name) {
    sql.exp = paste0("SELECT DISTINCT run.rid, input_setting.setup, input_setting.value AS `", parameter_name, "`
                     FROM ",mysql_dbname_from, ".input
                     JOIN ",mysql_dbname_from, ".input_setting ON input_setting.input_id = input.id
                     JOIN ",mysql_dbname_from, ".run ON run.setup = input_setting.setup
                     JOIN ",mysql_dbname_from, ".implementation ON input.implementation_id = implementation.id
                     WHERE input.name = '", parameter_name,"'
                     AND task_id = ", task_id, "
                     AND implementation.name = 'mlr.", algo_id, "'")
    result = dbGetQuery(con, sql.exp)
    for (i in seq_len(ncol(result))) {
      if (is.character(result[[i]])) {
        result[[i]] = type.convert(result[[i]])  
      }
    }
    return(result)
  })
  
  if(length(db_entries) == 0) {
    return(NULL)
  }
  
  # Merge results by same setup_ids
  if(length(db_entries) >= 2) {
    t = merge(db_entries[[1]], db_entries[[2]], all = TRUE, by = c("rid", "setup"))
    
    if(length(db_entries) >= 3) {
      for (i in 3:length(db_entries)) {
        t = merge(t, db_entries[[i]], all = TRUE, by = c("rid", "setup"))
      }
    }
  } else {
    t = db_entries[[1]]
  }
  
  setDT(t)
  
  # Add evaluation measures from `evaluation`-table.
  if(nrow(t) > 0) {
    function_ids = c(4,45,54,59,63)
    method_names = c("auc","accuracy","rmse","scimark","runtime")
    
    run_ids = sprintf("(%s)", paste0(simplify2array(t[,"rid"]), collapse=", "))
    
    measures = sprintf("SELECT `source` AS `rid`, `function_id`, `value` FROM %s.`evaluation` WHERE `source` IN %s AND `function_id` IN (4,45,54,59,63)", mysql_dbname_from, run_ids)
    result = dbGetQuery(con, measures)
  
    # Merge evaluation measures one-by-one into the table.
    for (i in seq_along(function_ids)) {
      function_id = function_ids[i]
      method_name = method_names[i]
      t2 = result[result[, "function_id"] == function_id, c("rid","value")]
      t3 = data.table(rid = t2$rid)
      t3[[method_name]] = t2$value
      t = merge(t, t3, all = TRUE, by = "rid")
    }
  }

  return(t)
}

#' Return a list of parameter definitions. This list contains every necessary parameter for the given algorithm.
#'
#' @param task_id This is `task_id` from the table `run` in the database.
#'
#' @return A named list with one entry for each needed parameter.
get_params_for_algo = function(algo_name) {
  # Load parameter data from pre-saved file "parameter_ranges".
  # See call to readRDS() on top of this file.
  
  if(is.null(parameter_ranges[[algo_name]])) {
    warning(paste0("No parameters found in `parameter_ranges` for algorithm name '", algo_name, "'."))
    return(list())
  } else {
    params = parameter_ranges[[algo_name]]$pars
    
    # We convert the data from some ParamHelper-class to simple JSON.
    params = lapply(params, paramToJSONList)
    
    return(params)
  }
}

#' Returns the default value for the given parameter on the given task
#'
#' @param algo_name The algorithm name the parameter belongs to.
#' @param param_name The parameter name.
get_parameter_default = function(algo_name, param_name) {
  params = get_params_for_algo(algo_name)
  def = params[[param_name]]$default
  return(def)
}

#' This replaces every NA in the given table with the correct default value.
#'
#' @param table The parameter table, as generated by get_parameter_table(...)
#' @param algo_name The algorithm name the parameters belong to.
#' @param param_names The parameter names as a vector.
#' @param task_id This is sometimes needed, because some defaults are data-dependent.
replace_na_with_defaults = function(table, algo_name, parameter_names) {
  for(parameter_name in parameter_names) {
    nas = is.na(table[[parameter_name]])
    if(any(nas)) {
      def = get_parameter_default(algo_name, parameter_name)
      if (!is.null(def)) {
        if(is.factor(table[[parameter_name]])) {
          table[[parameter_name]] = as.character(table[[parameter_name]]) 
        }
        table[[parameter_name]][nas] = def
      }
    }
  }
  
  return(table)
}

insertIntoDB = function(task_id, algo_id, t) {
  if(nrow(t) > 0) {
    parameters = "task_id INTEGER UNSIGNED"
    parameters = append(parameters, lapply(names(t), function(parameter_name) {
      class_of_parameter = class(simplify2array(t[1, ..parameter_name]))
      mysql_type = class_of_parameter
      if(parameter_name == "respect.unordered.factors") {
        class_of_parameter = "logical"
      }
      if(class_of_parameter == "factor") {
        mysql_type = "VARCHAR(255)"
      }
      if(class_of_parameter == "character") {
        mysql_type = "VARCHAR(255)"
      }
      if(class_of_parameter == "logical") {
        mysql_type = "BOOL"
      }
      if(class_of_parameter == "numeric") {
        mysql_type = "FLOAT"
      }
      if(parameter_name == "setup") {
        mysql_type = "INTEGER UNSIGNED"
      }
      if(parameter_name == "rid") {
        mysql_type = "INTEGER UNSIGNED"
      }
      return(sprintf("`%s` %s", parameter_name, mysql_type))
    }))
    parameters = paste0(parameters, collapse = ", ")
    sql.exp = sprintf("CREATE TABLE IF NOT EXISTS %s.`%s` (%s);", mysql_dbname_to, algo_id, parameters)
    dbExecute(con, sql.exp)
    
    t[,"task_id"] = task_id
    
    writeRows(algo_id, t)
  }
}

writeRows = function(algo_id, xt) {
  colnames = paste0(sprintf("`%s`", names(xt)), collapse = ", ")
  
  CHUNK_SIZE = 200

  for(i in 1:(nrow(xt)/CHUNK_SIZE)) {
    upper_bound = (i * CHUNK_SIZE)
    if(upper_bound > nrow(xt)) {
      upper_bound = nrow(xt)
    }
    
    t = xt[((i-1) * CHUNK_SIZE) : upper_bound, ]
    
    t_as_str = apply(t, 1, function(x) {
      strs = sapply(x, function(y) {
        y = trimws(y)
        if(is.na(y)) {
          "NULL"
        } else {
          if(y == 'TRUE' || y == 'FALSE') {
            sprintf("'%s'", ifelse(y == 'TRUE', 1, 0))
          } else {
            sprintf("'%s'", y)        
          }
        }
      })
      sprintf("(%s)", paste0(strs, collapse=", "))
    })
    t_as_str = paste0(t_as_str, collapse = ", ")
    sql.exp = sprintf("INSERT INTO %s.`%s` (%s) VALUES %s", mysql_dbname_to, algo_id, colnames, t_as_str)
    dbExecute(con, sql.exp)
  }
}

updateDatabase = function(task_id, algo_id) {
  t = getTableFromDB(task_id, algo_id)
  setDT(t)
  
  t = replace_na_with_defaults(t, algo_id, names(t))
  
  if("gamma" %in% names(t)) {
    cc = complete.cases(t[,-"gamma"])
  } else {
    cc = complete.cases(t)
  }
  
  cat(sprintf("Removing %.1f%% (%d/%d) of runs.\r\n", (sum(!cc) * 100.0 / dim(t)[1]), sum(!cc), dim(t)[1]))
  
  t = t[cc,]
  
  if(algo_id == "classif.ranger") {
    MIN_SETUP = 5991158 # Runs before this are reference runs, remove them.
    t = t[t[,setup >= MIN_SETUP],]
  }
  
  insertIntoDB(task_id, algo_id, t)
}

possibleTaskIDs = function() {
  return(c(3,4))
}

possibleAlgoIDs = function() {
  return(names(parameter_ranges))
}

cleanupOldTables = function() {
  for(algo_id in possibleAlgoIDs()) {
    sql.exp = sprintf("DROP TABLE IF EXISTS %s.`%s`;", mysql_dbname_to, algo_id)
    dbExecute(con, sql.exp)
  }
}

cleanupOldTables();

task_ids = possibleTaskIDs()
algo_ids = possibleAlgoIDs()
task_count = length(task_ids)
algo_count = length(algo_ids)

for(i in seq_along(task_ids)) {
  for(j in seq_along(algo_ids)) {
    ij = (i-1) * algo_count + j
    task_id = task_ids[i]
    algo_id = algo_ids[j]
    cat(sprintf("(Progress: %d / %d - %.0f%%) Importing Task %d (%d / %d) + Algorithm %s (%d / %d):\t",
                    ij, algo_count*task_count, (100*ij / (algo_count*task_count)),task_id, i, task_count, algo_id, j, algo_count))
    updateDatabase(task_ids[i], algo_ids[j])
  }
}
