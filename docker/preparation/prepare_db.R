library("RMySQL")
library("data.table")
library("ParamHelpers")

# Declare database credentials
mysql_username = "root"
mysql_password = ""
mysql_dbname_from = "openml_exporting"
mysql_dbname_to = "openml_reformatted"
mysql_host = "127.0.0.1"

# Open database connection
con <- dbConnect(MySQL(), user = mysql_username, password = mysql_password, dbname = mysql_dbname_to, host = mysql_host)
parameter_ranges = readRDS("../omlbotlookup/app/parameter_ranges.Rds")

#' Queries the database for a list of all run parameter configurations with the given algorithm ids, on the given task_id with every parameter in parameter_names.
#'
#' @param algo_id Algorithm id (eg. 'mlr.classif.ranger')
#' @param task_id A single task_id, on which the algorithm has been run.
#' @param parameter_names A vector or list of 
#'
#' @return A dataframe containing: A column "setup", with the setup_id. A column "<parameter_name>" for every parameter. And one row of data for every setup, that has been run with one of the given algorithms, containing the parameter_data of that run.
getTableFromDB = function(task_id, algo_id) {
  parameter_names = names(parameter_ranges[[algo_id]]$pars)
  
  db_entries = lapply(parameter_names, function(parameter_name) {
    sql.exp = paste0("SELECT DISTINCT run.rid, input_setting.setup, input_setting.value AS `", parameter_name, "`
                     FROM ",mysql_dbname_from, ".input
                     JOIN ",mysql_dbname_from, ".input_setting ON input_setting.input_id = input.id
                     JOIN ",mysql_dbname_from, ".run ON run.setup = input_setting.setup
                     JOIN ",mysql_dbname_from, ".implementation ON input.implementation_id = implementation.id
                     WHERE input.name = '", parameter_name,"'
                     AND task_id = ", task_id, "
                     AND implementation.name = 'mlr.", algo_id, "'")

    result = dbGetQuery(con, sql.exp)
    for (i in seq_len(ncol(result))) {
      if (is.character(result[[i]])) {
        result[[i]] = type.convert(result[[i]], as.is = TRUE)  
      }
    }
    return(result)
  })
  
  #cat(" (db done) ")
  
  if(length(db_entries) == 0) {
    return(NULL)
  }
  
  t = db_entries[[1]]
  # Merge results by same setup_ids
  for (i in seq_along(db_entries)[-1]) {
    t = merge(t, db_entries[[i]], all = TRUE, by = c("rid", "setup"))
  }
  
  setDT(t)
  
  #cat(" (add eval) ")
  
  # Add evaluation measures from `evaluation`-table.
  if(nrow(t) > 0) {
    function_ids = c(4,45,54,59,63)
    method_names = c("auc","accuracy","rmse","scimark","runtime")
    
    measures = sprintf("SELECT `source` AS `rid`, `function_id`, `value` FROM %s.`evaluation` JOIN %s.`run` ON source = rid WHERE `task_id` = '%i' AND `function_id` IN (%s)", mysql_dbname_from, mysql_dbname_from, task_id, paste0(function_ids, collapse = ","))
    result = dbGetQuery(con, measures)
    
    # Remove runs which are not currently selected (sql query above selected too many.)
    result = result[result$rid %in% t$rid,]
  
    #cat(" (db done) ")
    
    # Merge evaluation measures one-by-one into the table.
    for (i in seq_along(function_ids)) {
      function_id = function_ids[i]
      method_name = method_names[i]
      t2 = result[result[["function_id"]] == function_id, c("rid","value")]
      t3 = data.table(rid = t2$rid)
      t3[[method_name]] = t2$value
      t = merge(t, t3, all = TRUE, by = "rid")
    }
  }

  return(t)
}

#' Returns the default value for the given parameter on the given task
#'
#' @param algo_name The algorithm name the parameter belongs to.
#' @param param_name The parameter name.
get_parameter_default = function(algo_name, param_name) {
  params = parameter_ranges[[algo_name]]$pars
  def = params[[param_name]]$default
  return(def)
}

#' This replaces every NA in the given table with the correct default value.
#'
#' @param table The parameter table, as generated by get_parameter_table(...)
#' @param algo_name The algorithm name the parameters belong to.
#' @param param_names The parameter names as a vector.
#' @param task_id This is sometimes needed, because some defaults are data-dependent.
replace_na_with_defaults = function(table, algo_name, parameter_names) {
  for(parameter_name in parameter_names) {
    nas = is.na(table[[parameter_name]])
    if(any(nas)) {
      def = get_parameter_default(algo_name, parameter_name)
      if (!is.null(def)) {
        if(is.factor(table[[parameter_name]])) {
          table[[parameter_name]] = as.character(table[[parameter_name]]) 
        }
        table[[parameter_name]][nas] = def
      }
    }
  }
  
  return(table)
}

insertIntoDB = function(task_id, algo_id, t) {
  if(nrow(t) > 0) {
    parameters = "task_id INTEGER UNSIGNED"
    parameters = c(parameters, lapply(names(t), function(parameter_name) {
      class_of_parameter = class(simplify2array(t[1, ..parameter_name]))
      mysql_type = class_of_parameter
      if(parameter_name == "respect.unordered.factors") {
        class_of_parameter = "logical"
      }
      if(class_of_parameter == "factor") {
        mysql_type = "VARCHAR(255)"
      }
      if(class_of_parameter == "character") {
        mysql_type = "VARCHAR(255)"
      }
      if(class_of_parameter == "logical") {
        col = c(sapply(sapply(t[, ..parameter_name], as.logical), as.numeric))
        t[, (parameter_name) := col]
        mysql_type = "BOOL"
      }
      if(class_of_parameter == "numeric") {
        mysql_type = "FLOAT"
      }
      if(parameter_name == "setup") {
        mysql_type = "INTEGER UNSIGNED"
      }
      if(parameter_name == "rid") {
        mysql_type = "INTEGER UNSIGNED"
      }
      return(sprintf("`%s` %s", parameter_name, mysql_type))
    }))
    parameters = paste0(parameters, collapse = ", ")
    
    keys = sapply(names(t), function(key_name) {
      sprintf("KEY (`%s`)", key_name)
    })
    
    keys = paste0(keys, collapse=", ")
    
    sql.exp = sprintf("CREATE TABLE IF NOT EXISTS %s.`%s` (%s, %s);", mysql_dbname_to, algo_id, parameters, keys)
    
    # cat(sprintf("Table DESC: %s\n", sql.exp))
    
    dbExecute(con, sql.exp)
    
    t[,"task_id"] = task_id
    
    # Replace invalid default values with NA
    if(algo_id == "classif.svm") {
      t[t$kernel != "polynomial"]$degree = NA
    }
    
    writeRows(algo_id, t)
  }
}

writeRows = function(algo_id, xt) {
  dbWriteTable(con, algo_id, xt, append = T, row.names = F)
}

updateDatabase = function(task_id, algo_id) {
  t = getTableFromDB(task_id, algo_id)
  setDT(t)
  
  t = replace_na_with_defaults(t, algo_id, names(t))

  if("gamma" %in% names(t)) {
    cc = complete.cases(t[,-"gamma"])
  } else {
    cc = complete.cases(t)
  }
  
  cat(sprintf("Removing %.1f%% (%d/%d) of runs.\r\n", (sum(!cc) * 100.0 / dim(t)[1]), sum(!cc), dim(t)[1]))
  if(algo_id == "classif.ranger") {
    cat(sprintf("Ranger: Ratio of 'min.node.size is NA' / all runs: %.1f%%\r\n", 100 * sum(is.na(t$min.node.size)) / dim(t)[1]))
  }
  
  t = t[cc,]
  
  if(algo_id == "classif.ranger") {
    MIN_SETUP = 5991158 # Runs before this are reference runs, remove them.
    t = t[t[,setup >= MIN_SETUP],]
  }
  
  insertIntoDB(task_id, algo_id, t)
}

possibleTaskIDs = function() {
  sql.exp = paste0("SELECT DISTINCT task_id FROM ",mysql_dbname_from,".run")
  return(c(dbGetQuery(con, sql.exp))$task_id)
}

possibleAlgoIDs = function() {
  return(names(parameter_ranges))
}

cleanupOldTables = function() {
  for(algo_id in possibleAlgoIDs()) {
    sql.exp = sprintf("DROP TABLE IF EXISTS %s.`%s`;", mysql_dbname_to, algo_id)
    dbExecute(con, sql.exp)
  }
}

cleanupOldTables();

task_ids = possibleTaskIDs()
algo_ids = possibleAlgoIDs()
task_count = length(task_ids)
algo_count = length(algo_ids)

for(i in seq_along(task_ids)) {
  for(j in seq_along(algo_ids)) {
    ij = (i-1) * algo_count + j
    task_id = task_ids[i]
    algo_id = algo_ids[j]
    cat(sprintf("(Progress: %d / %d - %.0f%%) Importing Task %d (%d / %d) + Algorithm %s (%d / %d):\t",
                    ij, algo_count*task_count, (100*ij / (algo_count*task_count)),task_id, i, task_count, algo_id, j, algo_count))
    updateDatabase(task_ids[i], algo_ids[j])
  }
}


# algo_id = "classif.ranger"

# for (task_id in possibleTaskIDs()) {
#   updateDatabase(task_id, algo_id)
# }
